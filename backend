{
  "name": "web3dataentry-backend",
  "version": "1.0.0",
  "type": "module",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "axios": "^1.4.0",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "mongoose": "^7.6.1",
    "socket.io": "^4.7.5"
  }
}
PORT=5000
MONGO_URI=your_mongodb_connection_string_here
PI_USD_RATE=314159   # default per your request; change if needed
USD_INR_RATE=83      # example; set real INR rate or leave as default
import mongoose from "mongoose";

const userSchema = new mongoose.Schema({
  walletAddress: { type: String, required: true, unique: true }, // we will store Pi uid here
  fullName: { type: String, default: "" },
  consentLegal: { type: Boolean, default: false }, // user accepted legal doc
  createdAt: { type: Date, default: Date.now }
});

export default mongoose.model("User", userSchema);
import mongoose from "mongoose";

const earningSchema = new mongoose.Schema({
  user: { type: mongoose.Schema.Types.ObjectId, ref: "User", required: true },
  piAmount: { type: Number, required: true },
  usdAmount: { type: Number, required: true },
  inrAmount: { type: Number, required: true },
  note: { type: String, default: "" },
  createdAt: { type: Date, default: Date.now }
});

export default mongoose.model("Earning", earningSchema);
import express from "express";
import axios from "axios";
import User from "../models/User.js";

const router = express.Router();

// Demo manual login (fallback)
router.post("/login", async (req, res) => {
  try {
    const { walletAddress, fullName, consent } = req.body;
    if (!walletAddress || !fullName) return res.status(400).json({ success:false, message:"walletAddress & fullName required" });

    try {
      let user = await User.findOne({ walletAddress });
      if (!user) {
        user = new User({ walletAddress, fullName, consentLegal: !!consent });
        await user.save();
      } else {
        // update name/consent if provided
        user.fullName = fullName || user.fullName;
        if (typeof consent === "boolean") user.consentLegal = consent;
        await user.save();
      }
      return res.json({ success:true, user });
    } catch(dbErr) {
      console.error("DB error:", dbErr.message);
      return res.json({ success:true, user: { walletAddress, fullName }, warning:"DB error (demo fallback)" });
    }
  } catch (err) {
    console.error(err);
    return res.status(500).json({ success:false, message:"Server error" });
  }
});

// Verify Pi accessToken (Pi Browser flow)
router.post("/verify", async (req, res) => {
  try {
    const { accessToken } = req.body;
    if (!accessToken) return res.status(400).json({ success:false, message:"accessToken required" });

    // call Pi API
    try {
      const resp = await axios.get("https://api.minepi.com/v2/me", {
        headers: { Authorization: `Bearer ${accessToken}` }
      });
      const me = resp.data && resp.data.user ? resp.data.user : null;
      if (!me) return res.status(401).json({ success:false, message:"Invalid token" });

      const uid = me.uid;
      const username = me.username || "";

      try {
        let user = await User.findOne({ walletAddress: uid });
        if (!user) {
          user = new User({ walletAddress: uid, fullName: username, consentLegal: true });
          await user.save();
        }
        return res.json({ success:true, user: { id: user._id, walletAddress: user.walletAddress, fullName: user.fullName } });
      } catch(dbErr) {
        console.error("DB error:", dbErr.message);
        return res.json({ success:true, user: { walletAddress: uid, fullName: username }, warning:"DB error (demo fallback)" });
      }
    } catch(apiErr) {
      console.error("Pi API error:", apiErr.response ? apiErr.response.data : apiErr.message);
      return res.status(401).json({ success:false, message:"Pi verification failed" });
    }
  } catch(err) {
    console.error(err);
    return res.status(500).json({ success:false, message:"Server error" });
  }
});

export default router;
import express from "express";
import User from "../models/User.js";
import Earning from "../models/Earning.js";

const router = express.Router();

// POST /earnings/add
// body: { walletAddress (uid), piAmount, note }
// calculates USD & INR using env rates, saves, emits socket update via req.app.get('io')
router.post("/add", async (req, res) => {
  try {
    const { walletAddress, piAmount, note } = req.body;
    if (!walletAddress || typeof piAmount !== "number") return res.status(400).json({ success:false, message:"walletAddress & piAmount required" });

    const PI_USD_RATE = Number(process.env.PI_USD_RATE || process.env.PI_USD_RATE === "0" ? process.env.PI_USD_RATE : process.env.PI_USD_RATE || 314159);
    const USD_INR_RATE = Number(process.env.USD_INR_RATE || 83);

    const usd = piAmount * PI_USD_RATE;
    const inr = usd * USD_INR_RATE;

    let user = await User.findOne({ walletAddress });
    if (!user) return res.status(404).json({ success:false, message:"User not found" });

    const earning = new Earning({ user: user._id, piAmount, usdAmount: usd, inrAmount: inr, note: note || "" });
    await earning.save();

    // Emit real-time update via socket.io (if available)
    const io = req.app.get("io");
    if (io) {
      io.to(user.walletAddress).emit("earning:update", {
        piAmount,
        usdAmount: usd,
        inrAmount: inr,
        note: earning.note,
        createdAt: earning.createdAt
      });
    }

    return res.json({ success:true, earning });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ success:false, message:"Server error" });
  }
});

// GET /earnings/:walletAddress - list recent earnings for user
router.get("/:walletAddress", async (req, res) => {
  try {
    const { walletAddress } = req.params;
    const user = await User.findOne({ walletAddress });
    if (!user) return res.status(404).json({ success:false, message:"User not found" });

    const items = await Earning.find({ user: user._id }).sort({ createdAt: -1 }).limit(50);
    return res.json({ success:true, items });
  } catch(err) {
    console.error(err);
    return res.status(500).json({ success:false, message:"Server error" });
  }
});

export default router;
import express from "express";
import http from "http";
import { Server as IOServer } from "socket.io";
import cors from "cors";
import mongoose from "mongoose";
import dotenv from "dotenv";
import authRoutes from "./routes/auth.js";
import earningsRoutes from "./routes/earnings.js";

dotenv.config();
const app = express();
const server = http.createServer(app);
const io = new IOServer(server, { cors: { origin: "*" } });

app.use(cors({ origin: true, credentials: true }));
app.use(express.json());

// attach io to app so routes can use it
app.set("io", io);

// Mongo connect
if (process.env.MONGO_URI) {
  mongoose.connect(process.env.MONGO_URI)
    .then(()=>console.log("✅ MongoDB Connected"))
    .catch(err=>console.error("❌ MongoDB Error:", err.message));
} else console.log("⚠️ Running without MONGO_URI (demo mode)");

// Routes
app.use("/auth", authRoutes);
app.use("/earnings", earningsRoutes);

// Socket.io: join room by walletAddress (uid)
io.on("connection", (socket) => {
  console.log("Socket connected:", socket.id);
  socket.on("join", (walletAddress) => {
    if (walletAddress) {
      socket.join(walletAddress);
      console.log("Socket joined room:", walletAddress);
    }
  });
  socket.on("disconnect", ()=> console.log("Socket disconnected:", socket.id));
});

const PORT = process.env.PORT || 5000;
server.listen(PORT, ()=> console.log(`🌍 Server running on port ${PORT}`));
